#!/usr/bin/env python

"""
vrp.py:

Class instance for the base VRP.
"""

import numpy as np
from random import random, randint, shuffle


class VRP:
    """
    VRP - Vehicle Routing Problem. The base problem.
    
    Problem description:
    There are n number of cities (nodes) and one depot.
    Each city has to be visited. The travels start and end at the depot.
    You have m number of vehicles at your disposal, for the purpose of
    servicing the cities. Which vehicles should visit where so that total
    costs are as minimal as possible?
    """

    def __init__(self,
                 node_count,
                 depot_node,
                 vehicle_count,
                 vehicle_variance,
                 distance_time_ratio,
                 vehicle_capacity,
                 vrpp_enabled=False,
                 vrptw_enabled=False):
        """
        Constructor for an individual of the population. A solution is generated by default;
        however, it is neither evaluated in terms of fitness nor is it validated.
        :param node_count: Number of nodes considered in the problem. Depot node is included.
        :param depot_node: The number that is set to represent the depot node.
        :param vehicle_count: Number of vehicles that are used initially.
        :param vehicle_variance: Variance of the number of vehicles.
        :param distance_time_ratio: Determines how distance is converted to time.
        :param vehicle_capacity: Supply capacity of each vehicle.
        :param vrpp_enabled: Determines whether VRPP elements are being used.
        :param vrptw_enabled: Determines whether VRPTW elements are being used.
        """

        self.individual_id = "Unset"

        self.node_count = node_count
        self.depot_node = depot_node
        self.vehicle_count_initial = vehicle_count
        self.vehicle_count = vehicle_count
        self.vehicle_variance = vehicle_variance
        self.distance_time_ratio = distance_time_ratio

        # Vehicle capacities. Every vehicle is assumed to have the same capacity.
        self.vehicle_capacity = vehicle_capacity

        # Distance-to-time conversion function.
        if self.distance_time_ratio > 0:
            self.distance_to_time = lambda distance, ratio: distance / ratio
        else:
            self.distance_time_ratio = self.distance_time_ratio * (-1)
            self.distance_to_time = lambda distance, ratio: distance * ratio

        # Initialize a random solution.
        self.solution = list(range(self.node_count))
        shuffle(self.solution)

        # Exclude depot node from the solution.
        self.solution.remove(self.depot_node)

        # Set up checkpoints that determine the end and beginning of a route.
        # Number represents the index where a route ends, and the next index
        # starts a new route.
        self.routes = [randint(0, self.node_count - 1) for x in range(self.vehicle_count)]
        self.routes.sort()

        # This container keeps track of marked nodes (i.e. subject to mutations).
        self.marked_nodes = []

        # In VRPP, some nodes can remain unvisited. Those are kept here.
        self.unvisited_nodes = []

        # In VRPTW, it may be of interest for some vehicles to leave later than usual.
        # This variable keeps track of that for every vehicle.
        self.vehicle_departure = [0] * self.vehicle_count

        # Fitness value of the individual. The greater it is, the better individual is.
        # VRP is a minimization problem: excluding VRPP, fitness value will be mainly negative.
        # The evaluation of the fitness value is conducted outside the individual.
        self.fitness = np.inf

        # Configuring mutation functions.
        self.mutation1 = self._change_vehicle_count
        if vrpp_enabled:
            self.mutation2 = self._include_node
            self.mutation3 = self._exclude_node
        else:
            self.mutation2 = self._change_vehicle_count
            self.mutation3 = self._change_vehicle_count
        if vrptw_enabled:
            self.mutation4 = self._change_departure_time
        else:
            self.mutation4 = self._change_vehicle_count

    def print(self):
        """
        Prints unique information about the individual.
        """

        print("-------------------------------------------------")
        print("- Individual ID: {} ".format(self.individual_id))
        print("- Complete Path: {}".format(self.solution))
        print("- Vehicle Count: {}".format(self.vehicle_count))
        print("- Checkpoints:   {}".format(self.routes))
        print("- Departures:    {}".format(self.vehicle_departure))
        print("- Unused Nodes:  {}".format(self.unvisited_nodes))
        print("- Fitness Value: {}".format(self.fitness))

    def mutate(self, mutation_probability, followup_probability):
        """
        Mutates the individual. Mutation is rolled for each allele of the complete route.
        :param mutation_probability: Probability of mutation on a single allele.
        :param followup_probability: Probability of conducting node mutation on a successful roll
        with the previous check (mutation_probability).
        """

        for node in self.solution:
            roll = random()
            if roll < mutation_probability:
                # Successful roll. Now roll for either node mutation or
                # other form of mutation.
                followup = random()
                if followup < followup_probability:
                    # Successful followup roll. Mark node for mutation.
                    self.marked_nodes.append(node)
                else:
                    # Select one of 3 mutation functions.
                    selection = randint(1, 4)
                    if selection == 1:
                        self.mutation1()
                    elif selection == 2:
                        self.mutation2(node)
                    elif selection == 3:
                        self.mutation3()
                    elif selection == 4:
                        self.mutation4()

        self._node_mutation()

    def _node_mutation(self):
        """
        Mutates marked nodes by rearranging them.
        """

        # TODO
        self.marked_nodes.clear()

    def _change_vehicle_count(self, *args):
        """
        Mutates solution by changing vehicle count.
        """

        # TODO
        pass

    def _exclude_node(self, *args):
        """
        Mutates solution by excluding a node. This mutation function expects a parameter:
        Node subject to exclusion.
        """

        # TODO
        pass

    def _include_node(self, *args):
        """
        Mutates solution by including an excluded node. The excluded node is selected
        randomly.
        """

        # TODO
        pass

    def _change_departure_time(self, *args):
        """
        Mutates solution by modifying a vehicle's departure time.
        """

        # TODO
        pass
